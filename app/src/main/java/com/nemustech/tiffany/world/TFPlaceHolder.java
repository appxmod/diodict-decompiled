package com.nemustech.tiffany.world;

import java.util.Iterator;

/* loaded from: classes.dex */
public class TFPlaceHolder extends TFHolder {
    private static final String TAG = "TFPlaceHolder";
    private boolean bAutoGenerated;

    public boolean isAutoGenerated() {
        return this.bAutoGenerated;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setAutoGeneratedFlag(boolean flag) {
        this.bAutoGenerated = flag;
    }

    public TFPlaceHolder() {
        this.mIntendedOpacity = 1.0f;
    }

    public TFPlaceHolder(boolean terminalHolder) {
        this();
        setTerminalHolder(terminalHolder);
    }

    @Override // com.nemustech.tiffany.world.TFHolder
    public int getHeadSlotIndex(int slotCount) {
        return -1;
    }

    public void applyTouchEvent(TFModel model, float[] forceVector, int tickPassed) {
    }

    @Override // com.nemustech.tiffany.world.TFHolder
    public void layoutObjects(float headDeviation) {
    }

    @Override // com.nemustech.tiffany.world.TFHolder
    public boolean updateLayout(int tickPassed) {
        return false;
    }

    @Override // com.nemustech.tiffany.world.TFHolder
    public void setHeadItemIndex(int itemIndex, boolean showAnimation) {
    }

    @Override // com.nemustech.tiffany.world.TFHolder
    public boolean moveHeadModelStep(float step, boolean bindingAction) {
        return false;
    }

    public int scrollHeadItemIndex(int offset, boolean callListener) {
        return 0;
    }

    public int scrollHeadModelIndex(int offset) {
        return 0;
    }

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // com.nemustech.tiffany.world.TFHolder
    public void handleDown(TFModel selectedModel, int faceIndex, float x, float y) {
        this.mTouchDown = true;
        selectedModel.handleDown(faceIndex, x, y);
    }

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // com.nemustech.tiffany.world.TFHolder
    public void handleUp(TFModel selectedModel, float x, float y) {
        this.mTouchDown = false;
        selectedModel.handleUp(x, y);
    }

    /* JADX INFO: Access modifiers changed from: protected */
    @Override // com.nemustech.tiffany.world.TFHolder
    public void handleDrag(TFModel selectedModel, float startX, float startY, float endX, float endY, int tickPassed) {
        selectedModel.handleDrag(startX, startY, endX, endY, tickPassed);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @Override // com.nemustech.tiffany.world.TFHolder
    public boolean addModel(TFModel model, int slotIndex) {
        if (!isTerminalHolder()) {
            throw new IllegalArgumentException("Cannot attach a model to non terminal holder");
        }
        if (slotIndex > this.mObjectSlots.size()) {
            throw new IllegalArgumentException("Invalid slotIndex");
        }
        model.mParentHolder = this;
        model.mWorld = this.mWorld;
        TFObjectContainer oc = new TFObjectContainer(model);
        this.mObjectSlots.add(slotIndex, oc);
        setDrawOrder(this.mObjectSlots.size() - 1);
        onAddModel(model, slotIndex);
        if (this.mCloneList != null) {
            Iterator i$ = this.mCloneList.iterator();
            while (i$.hasNext()) {
                TFObject o = (TFObject) i$.next();
                try {
                    TFHolder h = (TFHolder) o;
                    h.addModel((TFModel) model.clone(), slotIndex);
                } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
                }
            }
        }
        refreshHolder();
        return true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @Override // com.nemustech.tiffany.world.TFHolder
    public TFModel removeModel(int slotIndex, boolean showAnimation) {
        TFModel model = null;
        if (isTerminalHolder() && slotIndex < getSlotCount()) {
            if (getSlotCount() <= 0) {
                throw new IllegalArgumentException("Nothing to remove");
            }
            model = (TFModel) this.mObjectSlots.remove(slotIndex).getObject();
            for (int i = slotIndex; i < getSlotCount(); i++) {
                this.mObjectSlots.get(i).getObject().setItemIndex(i);
            }
            setDrawOrder(slotIndex);
            onRemoveModel(model, slotIndex);
            if (this.mCloneList != null) {
                Iterator i$ = this.mCloneList.iterator();
                while (i$.hasNext()) {
                    TFObject o = (TFObject) i$.next();
                    ((TFHolder) o).removeModel(slotIndex);
                }
            }
            requestLayout();
        }
        return model;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @Override // com.nemustech.tiffany.world.TFHolder
    public boolean addHolder(TFHolder holder, int slotIndex) {
        if (isTerminalHolder()) {
            throw new IllegalArgumentException("Tried to attach a holder to terminal holder");
        }
        if (slotIndex > this.mObjectSlots.size()) {
            throw new IllegalArgumentException("The given slot index exceeds slot count");
        }
        holder.mParentHolder = this;
        holder.associateToWorld(this.mWorld);
        TFObjectContainer oc = new TFObjectContainer(holder);
        this.mObjectSlots.add(slotIndex, oc);
        setDrawOrder(this.mObjectSlots.size() - 1);
        onAddHolder(holder, slotIndex);
        if (this.mCloneList != null) {
            Iterator i$ = this.mCloneList.iterator();
            while (i$.hasNext()) {
                TFObject o = (TFObject) i$.next();
                try {
                    ((TFHolder) o).addHolder((TFHolder) holder.clone(), slotIndex);
                } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
                }
            }
        }
        refreshHolder();
        return true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @Override // com.nemustech.tiffany.world.TFHolder
    public TFHolder removeHolder(int slotIndex, boolean showAnimation) {
        if (isTerminalHolder()) {
            throw new IllegalArgumentException("This holder is a terminal holder which does not hold any holders but models");
        }
        if (slotIndex < 0 || getSlotCount() <= slotIndex) {
            throw new IllegalArgumentException("Slot index out of bounds");
        }
        if (getSlotCount() <= 0) {
            throw new IllegalArgumentException("Nothing to remove");
        }
        TFHolder holder = (TFHolder) this.mObjectSlots.remove(slotIndex).getObject();
        for (int i = slotIndex; i < getSlotCount(); i++) {
            this.mObjectSlots.get(i).getObject().setItemIndex(i);
        }
        setDrawOrder(slotIndex);
        onRemoveHolder(holder, slotIndex);
        if (this.mCloneList != null) {
            Iterator i$ = this.mCloneList.iterator();
            while (i$.hasNext()) {
                TFObject o = (TFObject) i$.next();
                ((TFHolder) o).removeHolder(slotIndex);
            }
        }
        requestLayout();
        return holder;
    }
}
